# Database_study



## 데이터베이스의 특징

1. 데이터의 독립성

   * 물리적 독립성: 데이터베이스의 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리더라도 관련된 응용 프로그램을 수정할 필요가 없다.
   * 논리적 독립성: 데이터베이스는 논리적인 구조로 다양한 응용 프로그의 논리적 요구를 충족시킬 수 있다.

   

2. 데이터 무결성

   > 여러 경로를 통해 데이터가 잘못들어오는 경우가 생길 수 있는 경우를 방지하기 위하여 유효성 검사를 통해 무결성을 구현한다.

   | 무결성 종류        | 설명                                                         |
   | ------------------ | ------------------------------------------------------------ |
   | 개체 무결성        | 모든 테이블은 Primary Key를 가지고 있어야 한다. Primary Key는 고유값이어야 하며, Not Null이어야 한다. |
   | 참조 무결성        | 외래키 속성은 참조 할 수 없는 값을 가지고 있을 수 없다. 또한 외래키는 Primary Key값이거나 NULL값이어야 한다. |
   | 속성 무결성        | 컬럼은 지정된 형식의 타입을 가지고 있어야 한다. ex) Char, Int, Text ... |
   | 키 무결성          | 한 릴레이션에 같은 키 값을 가진 튜플은 가능하지 않다.        |
   | 사용자 정의 무결성 | 모든 데이터는 업무 규칙을 준수해야한다. ex) Trigger, User Define Data Type, Default Value |
   | 도메인 무결성      | 기본값 설정, NOT NULL 옵션 등의 제약 사항으로 도메인 무결성을 보장할 수 있다. |

   | 무결성 확보 방안 (DBMS) | 설명                                                         |
   | ----------------------- | ------------------------------------------------------------ |
   | Primary Key             | 고유값을 가지고 있으며, NULL 값이 들어와서는 안된다.         |
   | Unique                  | 다중 보조키 개념 지원, Unique값은 NULL값 허용                |
   | Foreign Key             | **Foreign Key값은 반드시 참조하는 테이블의 Primary Key**, Foreign Key 값은 NULL 값 허용 |
   | Data Type               | Data Type은 지정된 형식을 따르게 하여 무결성을 유지          |
   | Default Value           | 특정 컬럼에 대해 명시적으로 값을 입력하지 않은 경우에 Default Value를 설정하여 자동으로 값을 삽입하도록 설정 |
   | Trigger                 | 테이블 내용을 수정하려는 특정 사건에 대해서 데이터베이스가 미리 정의된 일련의 행동을 하게 하는 것 |

* Foreign Key와 참조 무결성
  * RESTRICTED - 레코드를 변경, 삭제할 시 해당 레코드를 참조하고 있는 개체가 있다면 변경, 삭제를 취소한다.
  * CASCADE - 레코드를 변경, 삭제할 때 해당 레코드를 참조하고 있는 개체도 변경, 삭제한다.
  * SET NULL - 레코드를 삭제하면 해당 레코드를 참조하고 있는 개체의 값을 NULL로 설정한다.
* 데이터베이스 무결성 기대효과
  * Data 정확성 확보로 신뢰할 수 있는 정보 제공
  * Data 일관성 유지로 자료의 효율적인 관리



3. 데이터의 보안성
   * 허용된 사용자만이 데이터베이스 혹은 데이터베이스 내에 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정해놓으며 보안을 구현해놓을수있다.



## 데이터베이스 Index

> 데이터베이스 Index는 수정, 삭제의 성능은 떨어지더라도 조회의 속도가 매우 빨라진다.
>
> 검색 속도를 높이기 위한 데이터 구조
>
> indexing을 하기 위해서 테이블 재구성이 필요하며 이에 따른 비용과 별도의 저장공간이 필요하다.
>
> index를 생성하게되면 INSERT, UPDATE, DELETE에 별도의 과정이 추가된다.

* 인덱스는 키 값으로 행 데이터의 위치를 식별한다.
  * 원본 테이블 기준으로 별도의 Index 테이블을 생성해야한다.

1. Hash Index
   * 동등 비교 검색에는 최적화되어있지만 범위를 검색한다거나 정렬된 결과를 가져오는 목적으로는 사용하지 않는다.
   * 메모리 기반의 테이블에서 구현되어 있으며 디스크 기반의 대용량 테이블에는 사용하지 않는다.
2. B+Tree Index



* Index를 설계한다는 것!
  * 어떤 컬럼을 조합해서 인덱스를 작성할 것인지
  * 즉 어떻게 컬럼을 조합해야지 조회, 갱신의 모든 성능을 높일 수 있을지 고려하는 것
* Index 설계하면 좋은 경우
  * 데이터의 양이 많고, 검색이 변경, 삭제보다 많은 경우
  * 인덱스를 사용하고자하는 컬럼의 값이 다양한 경우

* Index 설계를 피해야하는 경우
  * 모든 컬럼이 인덱스인 경우
  * 인덱스에 포함된 컬럼이 하나밖에 없는 경우
  * 0 또는 1같은 값밖에 없는 플래그 컬럼이 인덱스인 경우



## 데이터베이스 정규화

> 불필요한 데이터를 제거하고, 데이터의 중복을 줄이고, 무결성을 향상시키는 목적
>
> 데이터베이스 구조 확장시 재디자인을 최소화하기 위히서
>
> 갱신 이상, 삽입 이상, 삭제 이상 등을 방지하기 위해서

1. 제 1정규화 (도메인이 원자값으로만 이루어져있는 경우)
   * 모든 속성은 원자값을 가져야한다.

2. 제 2정규화 (부분 함수 종속 제거)
   * 제 1정규형에 속하면서, **기본키가 아닌 모든 속성이 기본키에 완전 종속**되는 것
3.  제 3정규화 (이행적 함수 종속 제거)
   * X->Y, Y->Z 함수적 종속관계로 인해 X->Z 의 이행적 함수 종속 관계가 나타나면 [X, Y], [Y, Z] 두 릴레이션으로 분리한다.
4. 반정규화
   * 정규화되어있는 것을 정규화 하지않은 이전의 상태로 되돌리는 것