# 190116 알고리즘_배열

* #### 프로그래밍 절차 (그림을 그려서 문제를 풀어나가야함)

  * 요구사항분석 - 설계 - 구현- 테스트 - 유지보수




* #### 알고리즘 : 어떤 문제를 해결하기 위한 절차



* #### 빅오 표기법 

  : 시간 복잡도 함수 중에서 가장 큰 영향력을 주는 n에 대한 항만을 표시

   for의 중첩된 개수를 제곱으로 표현함 (따로따로이면 그냥 n)

* #### 정렬하는 법

  * 다중 for문을 자유자재로 쓸 수 있어야함!! 

``` 
O(log n) : 이진탐색
O(n) : 순차 탐색
O(nlog n) : Quick, 병합
O(n^2) : 선택, 버블 정렬, 삽입 정렬, 다이익스트라 최단경로 (for문 2개가 중첩되어 있다.)
O(n^3) : 프로이드의 최단경로(for문 3개가 중첩되어 있다.)

내려갈수록 시간이 더걸림
```

-> P(다항식) 문제이다.

```
O(2^n) : 부분집합
O(n!) : 순열 
```

-> NP 문제이다. 더 어려움



## 배열

* 프로그램 내에서 여러 개의 변수가 필요할 때 사용한다.

* 배열을 사용하면 하나의 선언을 통해서 둘 이상의 변수를 선언할 수 있다.

* 단순히 다수의 변수 선언을 의미하는 것이 아니라, 다수의 변수로는 하기 힘든 작업을 배열을 활용해 쉽게 할 수 있다.


#### <연습문제 1> (문제 난이도 : im 수준)

* 가로, 세로축 확인하기 (개수를 세야함)
* 크거나 같은지 확인
* 빼야하는 곳에서 시작해서 빼줘야함
* max_height = len(n) - (i+1)
* for문이 몇 개 필요한지 생각해보기



#### 완전 검색

* 생각할 수  있는 모든 경우의 수를 나열해보고 확인하는 기법
* 모든 경우의 수를 테스트한 후,  최종 해법을 도출한다.
* 일반적으로 경우의 수가 상대적으로 작을 때 유용하다.



#### counting 하는 방법을 알아야함!

그리디한 방법도 상황에 따라서 달라질 수 있다. 완전 검색, 그리디 방법 꼭 알고있기

정렬해도 되는 경우, 하면 안되는 경우 알고있기



## 정렬

#### 1. 버블정렬

* 인접한 두개의 원소를 비교하며 자리를 계속 교환하는 방식

* 정렬 과정

  1) 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하면서 맨 마지막 자리까지 이동한다.

  2) 한 단계가 끝나면 가장 큰 원소가 마지막 자리로 정렬된다.

  3) 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양과 같다고 하여 버블 정렬이라고 한다.

* 시간 복잡도 : O(n^2)

* 만약, 정렬해야할 것이 5개의 원소라면 4번 실행하며 자리를 바꿔준다. (for문 두개 사용)

  (4 - 3 - 2 - 1)

```
# call by value : 복사(일반 변수는 복사만 해줌)
# call by reference : 원본 참조 
  (원본이 바뀜 -> 원본을 참조시켜주기 때문에)
  (예를 들어, list 일 때 return 되는 값이 변한 값이기 때문에 바뀐 원본을 준다.)
# 재귀함수를 많이 쓰면 stack overflow가 생김

원본을 바꿔서 리턴한다. call by reference를 사용함!
```

-> 어떠한 문제를 풀 때는 꼭 그려보고 생각해보고 코드를 작성하며 문제를 풀어야함!



#### 2. 카운팅 정렬

* 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하여, 선형 시간에 정렬하는 효율적인 알고리즘

* 제한 사항

  1) 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능

   : 각 항목의 발생 회수를 기록하기 위해, 정수 항목으로 인덱스 되는 카운트들의 배열을 사용하기 때문이다.

  2) 카운트들을 위한 충분한 공간을 할당하려면 집함 내의 가장 큰 정수를 알아야 한다.

* 시간 복잡도 : O(n+k) : n은 리스트 길이, k는 정수의 최대값

* 원본을 건들지 않고 정렬한 것을 다른 list에 저장한다.

  참조도 사용함

```
DATA: 0부터 시작
COUNTS : 0부터 시작
TEMP : 1부터 시작
```

