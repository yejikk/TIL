# 190213 알고리즘

* 선형구조 : 앞 뒤 앞 뒤 일정한 것이 선형구조

* 비선형구조 : 트리와 같이 1:n 
  * 트리는 부모-자식 관계, cycle이 없는 것이 특징이다.
  * 

* 그래프 순회방식 : DFS => stack을 활용한다.
* LIFO 방식 : 후입선출, 마지막에 삽입한 자료를 가장 먼저 꺼낸다.



#### 스택의 구현

* ADT (추상자료형, 추상자료형) : class를 정의하는 것과 비슷하다.
  * 자료구조(변수)
    * 배열을 사용할 수 있는데 그 배열을 stack이라고 생각하고 사용한다.
    * 마지막을 알기 위해서 top이라는 위치를 알려주는 변수를 사용한다.
  *  연산
    * 삽입(push) : top을 먼저 증가시키고 top자리에 push, 스택의 크기와 비교
    * 삭제(pop): pop 먼저 하고 top을 감소, top의 크기와 비교
    * 공백인지?
    * 원소 반환



* 넘치는 것이 모자란 것보다 낫다. (모자라면 code가 실행되지 않기 때문에 메모리가 크더라도 넘치는 것이 나음.)



* 스택 구현 고려 사항
  * c에서 생기는 문제점



* 스택의 응용 : 괄호검사(**스택을 이용한 괄호 검사**) 다르게 생각할 줄 알아야함ㅠㅠ
  * 괄호의 종류
  * 조건
    * (와 )의 갯수가 같아야 한다.
    * 같은 괄호에서 왼쪽 괄호가 먼저 나와야한다.
    * 괄호 사이에 포함 관계만 존재한다. (괄호 종류가 섞여도 상관이 없음)
  * 괄호를 조사하는 알고리즘 개요
    * 문자열에 있는 괄호를 차례대로 조사하면서 왼쪽 괄호를 만나면 스택에 삽입(push), 오른쪽 괄호 만나면  삭제(pop)한 후 오른쪽과 짝이 맞는지 검사한다.



* 가지치기를 위해서 재귀호출이 필요함



* 스택의 응용2 : 재귀호출 () -> 재귀식 만드는 것이 제일 중요하다.



* 메모리제이션: DP에서 나오는 얘기 (재귀적 구조)
  * bottom -> up
  * 메모리제이션을 사용하면 피보나치의 시간을 O(n)으로 줄일 수 있다.
  * 어쨋든 재귀호출을 사용하는데 값을 저장하기 때문에 O(n)으로 줄인 것!



* DP : 동적계획 -> 점화식 만드는 것이 제일 중요하다.

  * 최적화 문제를 해결하는 알고리즘이다.
  * 동적계획 알고리즘은 먼저 입력 크기가 작은 부분 문제들을 모두 해결한 후에 그 해들을 이용하여 보다 큰 크기의 부분 문제들을 해결하여, 최종적으로 원래 주어진 입력의 문제를 해결하는 알고리즘이다.

  * 피보나치 수 DP 적용
    * 문제를 **부분 문제로 분할**한다!!!!!!!!!!!!!!!!!!!!!!
    * 작은 것부터 구해서 위로 올라간다.
    * 함수를 재귀처럼 돌리지 않고 반복문을 사용한다. (memorization 반복적 구조)

* memorization을 재귀적 구조에 사용하는 것보다 반복적 구조로  DP를 구현한 것이 성능면에서 보다 효율적이다.



* DFS(깊이 우선 탐색) 

  * while로 시작하면 맨 처음을 push해줘야한다.
  * 인접한 곳 push, pop해서 방문안했으면 인접한 곳  push

  

* 인접행렬 
  * 정점의 갯수만큼 2차원 행렬을 만든다.
  * 가중치가 없으면 1로 설정해준다.
  * 방향성이 없으면 전치행렬로 나온다. 
  * 있으면 진출, 진입차수가 존재함
    * 진출차수 (간선의 갯수 : 행의 합)
    * 진입차수 ()





